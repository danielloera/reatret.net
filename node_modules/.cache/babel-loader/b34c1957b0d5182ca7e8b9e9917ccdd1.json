{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _job = require('./job');\n\nvar _job2 = _interopRequireDefault(_job);\n\nvar _defaults = require('./defaults');\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nvar _ = require('./');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Pool = function (_EventEmitter) {\n  _inherits(Pool, _EventEmitter);\n\n  function Pool(threads) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Pool);\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    _this.threads = Pool.spawn(threads || _defaults2.default.pool.size, options);\n    _this.idleThreads = _this.threads.slice();\n    _this.jobQueue = [];\n    _this.runArgs = [];\n    _this.spawnOptions = options;\n\n    _this.on('newJob', function (job) {\n      return _this.handleNewJob(job);\n    });\n\n    _this.on('threadAvailable', function () {\n      return _this.dequeue();\n    });\n\n    return _this;\n  }\n\n  Pool.prototype.run = function run() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.runArgs = args;\n    return this;\n  };\n\n  Pool.prototype.send = function send() {\n    var _job$run;\n\n    if (!this.runArgs) {\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\n    }\n\n    var job = new _job2.default(this);\n    return (_job$run = job.run.apply(job, this.runArgs)).send.apply(_job$run, arguments);\n  };\n\n  Pool.prototype.killAll = function killAll() {\n    this.threads.forEach(function (thread) {\n      thread.kill();\n    });\n  };\n\n  Pool.prototype.queueJob = function queueJob(job) {\n    var _this2 = this;\n\n    job.once('abort', function () {\n      return _this2.dropJob(job);\n    }); // triggered by job.abort()\n\n    this.jobQueue.push(job);\n    this.dequeue();\n  };\n\n  Pool.prototype.dropJob = function dropJob(job) {\n    var index = this.jobQueue.indexOf(job);\n\n    if (index !== -1) {\n      this.jobQueue.splice(index, 1);\n    }\n  };\n\n  Pool.prototype.dequeue = function dequeue() {\n    var _this3 = this;\n\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\n      return;\n    }\n\n    var job = this.jobQueue.shift();\n    var thread = this.idleThreads.shift();\n    job.removeAllListeners('abort'); // remove previous listener\n\n    job.once('done', function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this3.handleJobSuccess.apply(_this3, [thread, job].concat(args));\n    }).once('error', function () {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this3.handleJobError.apply(_this3, [thread, job].concat(args));\n    }).once('abort', function () {\n      return _this3.handleJobAbort(thread, job);\n    });\n    job.executeOn(thread);\n  };\n\n  Pool.prototype.handleNewJob = function handleNewJob(job) {\n    var _this4 = this;\n\n    job.once('readyToRun', function () {\n      return _this4.queueJob(job);\n    }); // triggered by job.send()\n  };\n\n  Pool.prototype.handleJobSuccess = function handleJobSuccess(thread, job) {\n    for (var _len4 = arguments.length, responseArgs = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      responseArgs[_key4 - 2] = arguments[_key4];\n    }\n\n    this.emit.apply(this, ['done', job].concat(responseArgs));\n    this.handleJobDone(thread, job);\n  };\n\n  Pool.prototype.handleJobError = function handleJobError(thread, job, error) {\n    this.emit('error', job, error);\n    this.handleJobDone(thread, job);\n  };\n\n  Pool.prototype.handleJobDone = function handleJobDone(thread, job) {\n    var _this5 = this;\n\n    job.destroy(); // to prevent memory leak\n\n    this.idleThreads.push(thread);\n    this.emit('threadAvailable');\n\n    if (this.idleThreads.length === this.threads.length) {\n      // run deferred to give other job.on('done') handlers time to run first\n      setTimeout(function () {\n        _this5.emit('finished');\n      }, 0);\n    }\n  };\n\n  Pool.prototype.handleJobAbort = function handleJobAbort(thread, job) {\n    thread.kill();\n    var index = this.threads.indexOf(thread);\n    var newThread = (0, _.spawn)(null, [], this.spawnOptions);\n    this.threads.splice(index, 1, newThread);\n    this.handleJobDone(newThread, job);\n  };\n\n  return Pool;\n}(_eventemitter2.default);\n\nexports.default = Pool;\n\nPool.spawn = function (threadCount, options) {\n  var threads = [];\n\n  for (var threadIndex = 0; threadIndex < threadCount; threadIndex++) {\n    threads.push((0, _.spawn)(null, [], options));\n  }\n\n  return threads;\n};","map":{"version":3,"sources":["pool.js"],"names":["Pool","options","threads","run","args","send","job","killAll","thread","queueJob","dropJob","index","dequeue","handleNewJob","handleJobSuccess","responseArgs","handleJobError","error","handleJobDone","setTimeout","handleJobAbort","newThread","threadIndex"],"mappings":"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","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport Job          from './job';\nimport defaults     from './defaults';\nimport { spawn }    from './';\n\nexport default class Pool extends EventEmitter {\n  constructor(threads, options = {}) {\n    super();\n    this.threads = Pool.spawn(threads || defaults.pool.size, options);\n    this.idleThreads = this.threads.slice();\n    this.jobQueue = [];\n    this.runArgs = [];\n    this.spawnOptions = options;\n\n    this.on('newJob', (job) => this.handleNewJob(job));\n    this.on('threadAvailable', () => this.dequeue());\n  }\n\n  run(...args) {\n    this.runArgs = args;\n    return this;\n  }\n\n  send(...args) {\n    if (!this.runArgs) {\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\n    }\n\n    const job = new Job(this);\n    return job.run(...this.runArgs).send(...args);\n  }\n\n  killAll() {\n    this.threads.forEach(thread => {\n      thread.kill();\n    });\n  }\n\n  queueJob(job) {\n    job.once('abort', () => this.dropJob(job));  // triggered by job.abort()\n    this.jobQueue.push(job);\n    this.dequeue();\n  }\n\n  dropJob(job) {\n    const index = this.jobQueue.indexOf(job);\n    if (index !== -1) {\n      this.jobQueue.splice(index, 1);\n    }\n  }\n\n  dequeue() {\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\n      return;\n    }\n\n    const job = this.jobQueue.shift();\n    const thread = this.idleThreads.shift();\n\n    job.removeAllListeners('abort'); // remove previous listener\n\n    job\n      .once('done', (...args) => this.handleJobSuccess(thread, job, ...args))\n      .once('error', (...args) => this.handleJobError(thread, job, ...args))\n      .once('abort', () => this.handleJobAbort(thread, job));\n\n    job.executeOn(thread);\n  }\n\n  handleNewJob(job) {\n    job.once('readyToRun', () => this.queueJob(job));    // triggered by job.send()\n  }\n\n  handleJobSuccess(thread, job, ...responseArgs) {\n    this.emit('done', job, ...responseArgs);\n    this.handleJobDone(thread, job);\n  }\n\n  handleJobError(thread, job, error) {\n    this.emit('error', job, error);\n    this.handleJobDone(thread, job);\n  }\n\n  handleJobDone(thread, job) {\n    job.destroy();                    // to prevent memory leak\n    this.idleThreads.push(thread);\n    this.emit('threadAvailable');\n\n    if (this.idleThreads.length === this.threads.length) {\n      // run deferred to give other job.on('done') handlers time to run first\n      setTimeout(() => { this.emit('finished'); }, 0);\n    }\n  }\n\n  handleJobAbort(thread, job) {\n    thread.kill();\n\n    const index = this.threads.indexOf(thread);\n    const newThread = spawn(null, [], this.spawnOptions);\n\n    this.threads.splice(index, 1, newThread);\n    this.handleJobDone(newThread, job);\n  }\n}\n\nPool.spawn = (threadCount, options) => {\n  const threads = [];\n\n  for (let threadIndex = 0; threadIndex < threadCount; threadIndex++) {\n    threads.push(spawn(null, [], options));\n  }\n\n  return threads;\n};\n"]},"metadata":{},"sourceType":"script"}