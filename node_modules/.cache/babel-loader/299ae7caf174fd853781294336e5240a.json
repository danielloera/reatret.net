{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.resetPortCounter = undefined;\n\nvar _child_process = require('child_process');\n\nvar _child_process2 = _interopRequireDefault(_child_process);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _config = require('../config');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Mutable variable with the last port used for inspect/inspect-brk.\n// This value is shared among all workers.\n\n\nvar lastPort = 0; // Port used by Node.JS when there is no port specified. See\n// https://nodejs.org/en/docs/inspector/#command-line-options\n\nvar DEFAULT_PORT = 9229;\n\nvar buildExecArgv = function buildExecArgv() {\n  return process.execArgv.map(function (arg) {\n    var matches = arg.match(/^(--inspect(?:-brk)?)(?:=(\\d+))?/);\n    if (!matches) return arg;\n    var command = matches[1];\n    if (lastPort === 0) lastPort = Number(matches[2]) || 9229;\n    lastPort++;\n    return command + '=' + lastPort;\n  });\n}; // This function will reset the counter of ports used for inspect/inspect-brk.\n// Used for testing.\n\n\nvar resetPortCounter = exports.resetPortCounter = function resetPortCounter() {\n  lastPort = 0;\n};\n\nvar Worker = function (_EventEmitter) {\n  _inherits(Worker, _EventEmitter);\n\n  function Worker(initialRunnable) {\n    var importScripts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Worker);\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this)); // `importScripts` cannot be consumed, it's just there to keep the API compatible to the browser worker\n\n\n    _this.slave = _child_process2.default.fork(_path2.default.join(__dirname, 'slave.js'), [], Object.assign({\n      execArgv: buildExecArgv()\n    }, options));\n\n    _this.slave.on('message', _this.handleMessage.bind(_this));\n\n    _this.slave.on('error', _this.handleError.bind(_this));\n\n    _this.slave.on('exit', _this.emit.bind(_this, 'exit'));\n\n    if (initialRunnable) {\n      _this.run(initialRunnable);\n    }\n\n    return _this;\n  }\n\n  Worker.prototype.run = function run(toRun) {\n    if (typeof toRun === 'function') {\n      this.runMethod(toRun);\n    } else {\n      this.runScript(toRun);\n    }\n\n    return this;\n  };\n\n  Worker.prototype.runMethod = function runMethod(method) {\n    this.slave.send({\n      initByMethod: true,\n      method: method.toString()\n    });\n  };\n\n  Worker.prototype.runScript = function runScript(script) {\n    if (!script) {\n      throw new Error('Must pass a function or a script path to run().');\n    }\n\n    var prefixedScriptPath = _path2.default.join((0, _config.getConfig)().basepath.node, script); // attention: single script for node, array for browser\n\n\n    this.slave.send({\n      initByScript: true,\n      script: _path2.default.resolve(prefixedScriptPath)\n    });\n  };\n\n  Worker.prototype.send = function send(param) {\n    this.slave.send({\n      doRun: true,\n      param: param\n    });\n    return this;\n  };\n\n  Worker.prototype.kill = function kill() {\n    this.slave.kill();\n    return this;\n  };\n\n  Worker.prototype.promise = function promise() {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      var resolved = void 0,\n          rejected = void 0;\n\n      resolved = function resolved(result) {\n        _this2.removeListener('error', rejected);\n\n        resolve(result);\n      };\n\n      rejected = function rejected(err) {\n        _this2.removeListener('message', resolved);\n\n        reject(err);\n      };\n\n      _this2.once('message', resolved).once('error', rejected);\n    });\n  };\n\n  Worker.prototype.handleMessage = function handleMessage(message) {\n    if (message.error) {\n      var error = new Error(message.error.message);\n      error.stack = message.error.stack;\n      this.handleError(error);\n    } else if (message.progress) {\n      this.handleProgress(message.progress);\n    } else {\n      this.emit.apply(this, ['message'].concat(message.response));\n      this.emit.apply(this, ['done'].concat(message.response)); // this one is just for convenience\n    }\n  };\n\n  Worker.prototype.handleProgress = function handleProgress(progress) {\n    this.emit('progress', progress);\n  };\n\n  Worker.prototype.handleError = function handleError(error) {\n    if (!this.listeners('error', true)) {\n      console.error(error.stack || error); // eslint-disable-line no-console\n    }\n\n    this.emit('error', error);\n  };\n\n  return Worker;\n}(_eventemitter2.default);\n\nexports.default = Worker;","map":{"version":3,"sources":["worker.node/worker.js"],"names":["lastPort","DEFAULT_PORT","buildExecArgv","matches","arg","command","Number","resetPortCounter","Worker","importScripts","options","Object","execArgv","run","toRun","runMethod","method","initByMethod","runScript","script","prefixedScriptPath","initByScript","send","param","doRun","kill","promise","resolved","rejected","resolve","reject","handleMessage","message","error","handleProgress","progress","handleError","console"],"mappings":";;;;;AAAA,IAAA,cAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAEA;AACA;;;AACA,IAAIA,QAAAA,GAAJ,CAAA,C,CAEA;AACA;;AACA,IAAMC,YAAAA,GAAN,IAAA;;AACA,IAAMC,aAAAA,GAAgB,SAAhBA,aAAgB,GAAA;AAAA,SAAM,OAAA,CAAA,QAAA,CAAA,GAAA,CAAqB,UAAA,GAAA,EAAO;AACtD,QAAMC,OAAAA,GAAUC,GAAAA,CAAAA,KAAAA,CAAhB,kCAAgBA,CAAhB;AACA,QAAI,CAAJ,OAAA,EAAc,OAAA,GAAA;AAEd,QAAMC,OAAAA,GAAUF,OAAAA,CAAhB,CAAgBA,CAAhB;AACA,QAAIH,QAAAA,KAAJ,CAAA,EAAoBA,QAAAA,GAAWM,MAAAA,CAAOH,OAAAA,CAAPG,CAAOH,CAAPG,CAAAA,IAAXN,IAAAA;AACpBA,IAAAA,QAAAA;AACA,WAAUK,OAAV,GAAA,GAAUA,GAAV,QAAA;AAPoB,GAAM,CAAN;AAAtB,CAAA,C,CAUA;AACA;;;AACO,IAAME,gBAAAA,GAAAA,OAAAA,CAAAA,gBAAAA,GAAmB,SAAnBA,gBAAmB,GAAM;AACpCP,EAAAA,QAAAA,GAAAA,CAAAA;AADK,CAAA;;IAIcQ,M;;;AACnB,WAAA,MAAA,CAAA,eAAA,EAA+D;AAAA,QAAlCC,aAAkC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAlB,EAAkB;AAAA,QAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;AAAA,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EAE7D,aAAA,CAAA,IAAA,CAF6D,IAE7D,CAF6D,CAAA,CAAA,CAC7D;;;AAGA,IAAA,KAAA,CAAA,KAAA,GAAa,eAAA,CAAA,OAAA,CAAA,IAAA,CAAW,MAAA,CAAA,OAAA,CAAA,IAAA,CAAA,SAAA,EAAX,UAAW,CAAX,EAAA,EAAA,EAAiDC,MAAAA,CAAAA,MAAAA,CAC5D;AAAEC,MAAAA,QAAAA,EAAUV,aADgDS;AAC5D,KAD4DA,EAA9D,OAA8DA,CAAjD,CAAb;;AAIA,IAAA,KAAA,CAAA,KAAA,CAAA,EAAA,CAAA,SAAA,EAAyB,KAAA,CAAA,aAAA,CAAA,IAAA,CAAzB,KAAyB,CAAzB;;AACA,IAAA,KAAA,CAAA,KAAA,CAAA,EAAA,CAAA,OAAA,EAAuB,KAAA,CAAA,WAAA,CAAA,IAAA,CAAvB,KAAuB,CAAvB;;AACA,IAAA,KAAA,CAAA,KAAA,CAAA,EAAA,CAAA,MAAA,EAAsB,KAAA,CAAA,IAAA,CAAA,IAAA,CAAA,KAAA,EAAtB,MAAsB,CAAtB;;AAEA,QAAA,eAAA,EAAqB;AACnB,MAAA,KAAA,CAAA,GAAA,CAAA,eAAA;AACD;;AAd4D,WAAA,KAAA;AAe9D;;mBAEDE,G,gBAAIC,K,EAAO;AACT,QAAI,OAAA,KAAA,KAAJ,UAAA,EAAiC;AAC/B,WAAA,SAAA,CAAA,KAAA;AADF,KAAA,MAEO;AACL,WAAA,SAAA,CAAA,KAAA;AACD;;AACD,WAAA,IAAA;;;mBAGFC,S,sBAAUC,M,EAAQ;AAChB,SAAA,KAAA,CAAA,IAAA,CAAgB;AACdC,MAAAA,YAAAA,EADc,IAAA;AAEdD,MAAAA,MAAAA,EAAeA,MAAAA,CAAAA,QAAAA;AAFD,KAAhB;;;mBAMFE,S,sBAAUC,M,EAAQ;AAChB,QAAI,CAAJ,MAAA,EAAa;AAAE,YAAM,IAAA,KAAA,CAAN,iDAAM,CAAN;AAAqE;;AAEpF,QAAMC,kBAAAA,GAAqB,MAAA,CAAA,OAAA,CAAA,IAAA,CAAU,CAAA,GAAA,OAAA,CAAA,SAAA,IAAA,QAAA,CAAV,IAAA,EAA3B,MAA2B,CAA3B,CAHgB,CAKhB;;;AACA,SAAA,KAAA,CAAA,IAAA,CAAgB;AACdC,MAAAA,YAAAA,EADc,IAAA;AAEdF,MAAAA,MAAAA,EAAe,MAAA,CAAA,OAAA,CAAA,OAAA,CAAA,kBAAA;AAFD,KAAhB;;;mBAMFG,I,iBAAKC,K,EAAO;AACV,SAAA,KAAA,CAAA,IAAA,CAAgB;AACdC,MAAAA,KAAAA,EADc,IAAA;AAEdD,MAAAA,KAAAA,EAAAA;AAFc,KAAhB;AAIA,WAAA,IAAA;;;mBAGFE,I,mBAAO;AACL,SAAA,KAAA,CAAA,IAAA;AACA,WAAA,IAAA;;;mBAGFC,O,sBAAU;AAAA,QAAA,MAAA,GAAA,IAAA;;AACR,WAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AACtC,UAAIC,QAAAA,GAAAA,KAAJ,CAAA;AAAA,UAAcC,QAAAA,GAAAA,KAAd,CAAA;;AACAD,MAAAA,QAAAA,GAAW,SAAA,QAAA,CAAA,MAAA,EAAY;AACrB,QAAA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,QAAA;;AACAE,QAAAA,OAAAA,CAAAA,MAAAA,CAAAA;AAFFF,OAAAA;;AAIAC,MAAAA,QAAAA,GAAW,SAAA,QAAA,CAAA,GAAA,EAAS;AAClB,QAAA,MAAA,CAAA,cAAA,CAAA,SAAA,EAAA,QAAA;;AACAE,QAAAA,MAAAA,CAAAA,GAAAA,CAAAA;AAFFF,OAAAA;;AAKA,MAAA,MAAA,CAAA,IAAA,CAAA,SAAA,EAAA,QAAA,EAAA,IAAA,CAAA,OAAA,EAAA,QAAA;AAXF,KAAO,CAAP;;;mBAiBFG,a,0BAAcC,O,EAAS;AACrB,QAAIA,OAAAA,CAAJ,KAAA,EAAmB;AACjB,UAAMC,KAAAA,GAAQ,IAAA,KAAA,CAAUD,OAAAA,CAAAA,KAAAA,CAAxB,OAAc,CAAd;AACAC,MAAAA,KAAAA,CAAAA,KAAAA,GAAcD,OAAAA,CAAAA,KAAAA,CAAdC,KAAAA;AAEA,WAAA,WAAA,CAAA,KAAA;AAJF,KAAA,MAKO,IAAID,OAAAA,CAAJ,QAAA,EAAsB;AAC3B,WAAA,cAAA,CAAoBA,OAAAA,CAApB,QAAA;AADK,KAAA,MAEA;AACL,WAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAA,CAAA,SAAA,EAAA,MAAA,CAAwBA,OAAAA,CAAxB,QAAA,CAAA;AACA,WAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAA,CAAA,MAAA,EAAA,MAAA,CAAqBA,OAAAA,CAFhB,QAEL,CAAA,EAFK,CAEsC;AAC5C;;;mBAGHE,c,2BAAeC,Q,EAAU;AACvB,SAAA,IAAA,CAAA,UAAA,EAAA,QAAA;;;mBAGFC,W,wBAAYH,K,EAAO;AACjB,QAAI,CAAC,KAAA,SAAA,CAAA,OAAA,EAAL,IAAK,CAAL,EAAoC;AAClCI,MAAAA,OAAAA,CAAAA,KAAAA,CAAcJ,KAAAA,CAAAA,KAAAA,IADoB,KAClCI,EADkC,CACS;AAC5C;;AACD,SAAA,IAAA,CAAA,OAAA,EAAA,KAAA;;;;;;kBAnGiB7B,M","sourcesContent":["import child        from 'child_process';\nimport path         from 'path';\nimport EventEmitter from 'eventemitter3';\n\nimport { getConfig } from '../config';\n\n// Mutable variable with the last port used for inspect/inspect-brk.\n// This value is shared among all workers.\nlet lastPort = 0;\n\n// Port used by Node.JS when there is no port specified. See\n// https://nodejs.org/en/docs/inspector/#command-line-options\nconst DEFAULT_PORT = 9229;\nconst buildExecArgv = () => process.execArgv.map(arg => {\n  const matches = arg.match(/^(--inspect(?:-brk)?)(?:=(\\d+))?/);\n  if (!matches) return arg;\n\n  const command = matches[1];\n  if (lastPort === 0) lastPort = Number(matches[2]) || 9229;\n  lastPort++;\n  return `${command}=${lastPort}`\n});\n\n// This function will reset the counter of ports used for inspect/inspect-brk.\n// Used for testing.\nexport const resetPortCounter = () => {\n  lastPort = 0;\n}\n\nexport default class Worker extends EventEmitter {\n  constructor(initialRunnable, importScripts = [], options = {}) {\n    // `importScripts` cannot be consumed, it's just there to keep the API compatible to the browser worker\n    super();\n\n    this.slave = child.fork(path.join(__dirname, 'slave.js'), [], Object.assign(\n      { execArgv: buildExecArgv() },\n      options\n    ));\n    this.slave.on('message', this.handleMessage.bind(this));\n    this.slave.on('error', this.handleError.bind(this));\n    this.slave.on('exit', this.emit.bind(this, 'exit'));\n\n    if (initialRunnable) {\n      this.run(initialRunnable);\n    }\n  }\n\n  run(toRun) {\n    if (typeof toRun === 'function') {\n      this.runMethod(toRun);\n    } else {\n      this.runScript(toRun);\n    }\n    return this;\n  }\n\n  runMethod(method) {\n    this.slave.send({\n      initByMethod : true,\n      method       : method.toString()\n    });\n  }\n\n  runScript(script) {\n    if (!script) { throw new Error('Must pass a function or a script path to run().'); }\n\n    const prefixedScriptPath = path.join(getConfig().basepath.node, script);\n\n    // attention: single script for node, array for browser\n    this.slave.send({\n      initByScript : true,\n      script       : path.resolve(prefixedScriptPath)\n    });\n  }\n\n  send(param) {\n    this.slave.send({\n      doRun : true,\n      param\n    });\n    return this;\n  }\n\n  kill() {\n    this.slave.kill();\n    return this;\n  }\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      let resolved, rejected;\n      resolved = (result) => {\n        this.removeListener('error', rejected);\n        resolve(result);\n      };\n      rejected = (err) => {\n        this.removeListener('message', resolved);\n        reject(err);\n      };\n\n      this\n        .once('message', resolved)\n        .once('error', rejected);\n    });\n  }\n\n  handleMessage(message) {\n    if (message.error) {\n      const error = new Error(message.error.message);\n      error.stack = message.error.stack;\n\n      this.handleError(error);\n    } else if (message.progress) {\n      this.handleProgress(message.progress);\n    } else {\n      this.emit('message', ...message.response);\n      this.emit('done', ...message.response);    // this one is just for convenience\n    }\n  }\n\n  handleProgress(progress) {\n    this.emit('progress', progress);\n  }\n\n  handleError(error) {\n    if (!this.listeners('error', true)) {\n      console.error(error.stack || error);       // eslint-disable-line no-console\n    }\n    this.emit('error', error);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}